## 최댓값, 최솟값 구하기

```java
import java.util.*;
import java.io.*;

class Main {
    static int[] arr;
    public static void main(String[] args) {
        
        arr = new int[] {1, 3, 5, 2, 6, 7, 7, 9};
        
        System.out.println("최댓값: " + getMax(0));
        System.out.println("최솟값: " + getMin(0));
    }
    
    // 최댓값 구하기
    static int getMax(int n) {
        if(n == arr.length - 1) return arr[n];
        return Math.max(arr[n], getMax(n + 1));
    }

    // 최솟값 구하기
    static int getMin(int n) {
        if(n == arr.length - 1) return arr[n];
        return Math.min(arr[n], getMin(n + 1));
    }
}


```

```
최댓값: 9
최솟값: 1
```

1. 재귀 호출

\- f(n) -> Math.Max(arr[n], f(n+1))

\- f(n)은 두 수의 최댓값을 비교한 값을 리턴한다.

\- f(n)은 arr[n]과 f(n+1)의 최댓값을 비교한다.

&nbsp;

2. 기저 조건
   
\- f(n)은 배열의 길이만큼 만나면 return한다.

---

## 거듭제곱값 계산

```java
import java.util.*;
import java.io.*;

class Main {
    static int[] arr;
    public static void main(String[] args) {
        
        System.out.print(power(2, 10));
    }
    
    static int power(int x, int n) { 
        if(n==0) return 1; // 기저 조건
        else if(n % 2 == 0) return power(x * x, n/2); // 지수가 짝수일 때
        else return x * power(x * x, (n-1) / 2); // 지수가 홀수일 때
    }
    
}
```

```
1024
```

안쪽에 일어나는 일에 집중하지말고, 재귀 함수 자체를 이해하자

&nbsp;

일반 반복문을 사용했다면, 지수의 개수만큼 x을 곱했으니 시간복잡도가 O(n)이 나오게 된다.

하지만 재귀함수를 이용한 경우, 재귀로 자신을 호출할 때마다 문제의 크기가 절반씩 줄어들어 시간복잡도가 O(logn)이 나오게 된다.

피보나치 함수의 재귀 사용 효율을 높이고 싶다면, 그땐 메모이제이션을 사용하면 된다.

---

## 피보나치 함수

재귀 사용
```java
import java.util.*;
import java.io.*;

class Main {
    
    public static void main(String[] args) throws IOException {
        
        System.out.print(fibo(7));
        
    }
    
    static int fibo(int n) { 
        if(n == 0) return 0;
        if(n == 1) return 1;
        return fibo(n-1) + fibo(n-2);
    }
    
}
```
```
13
```

0, 1, 1, 2, 3, 5, 8, 13, 21...

f(7) -> f(6) + f(5) 호출
f(6) -> f(5) + f(4) 호출
...
f(n) -> f(n-1) + f(n-2) 호출

재귀를 이용한 피보나치 함수 같은 경우에는 이미 계산했던 값을 또 계산하게 되는 결과를 낫게 되기에, 시간 복잡도가 좋지 않다.

피보나치 함수 같은 경우는 일반 반복문을 이용해서 푸는 것이 더 효율적이라고 할 수 있다.

&nbsp;

반복문 사용
```java
import java.util.*;
import java.io.*;

class Main {
    
    public static void main(String[] args) throws IOException {
        
        System.out.print(fibo(7));
        
    }
    
    static int fibo(int n) { 
        if(n==0) return 0;
        if(n==1) return 1;
        
        int a = 0, b = 1; // 피보나치 함수의 첫번째항, 두번째항
        int sum = 0;
        
        for(int i=2; i<=n; i++) {
            sum = a + b;
            a = b;
            b = sum;
        }
        
        return sum;
    }
    
}
```
```
13
```

배열로 푸는 방법도 있는데, 더 간단하다. fibo[i] = fibo[i - 1] + fibo[i - 2]을 이용하면 된다.

---

